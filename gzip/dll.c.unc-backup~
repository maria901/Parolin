/*
    Copyright (C) <2021>  <BinaryWork Corp.>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU GENERAL PUBLIC LICENSE
        and GNU LESSER GENERAL PUBLIC LICENSE along with this program.
        If not, see <http://www.gnu.org/licenses/>.

    support: https://arsoftware.net.br/binarywork _____________
    mirror :  http://nomade.sourceforge.net/?AR=true&ar_debug=1

        direct programmers e-mails:
        Ricardo: arsoftware25@gmail.com  ricardo@arsoftware.net.br
         Amanda: arsoftware10@gmail.com  amanda@arsoftware.net. br

        immediate contact(for a very fast answer) WhatsApp
        (+55)41 9627 1708 - it is always on
 */

// definicao de uint e uchar, but why?...
#ifndef uchar
#define uchar unsigned char
#endif

#ifndef uint
#define uint unsigned int
#endif

#ifndef ushort
#define ushort unsigned short
#endif

#include <windows.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <fcntl.h>
#include <ctype.h>
#include <math.h>
#include <wctype.h>
#include <wchar.h>
#include <stdarg.h>
#include <stddef.h>
#include <setjmp.h>
#include <locale.h>
#include <signal.h>
#include <limits.h>
#include <float.h>
#include <iso646.h>

#undef NDEBUG
#include <assert.h>

#include "aline_definitive_header_2_.h"
#ifdef WIN64
#define MYCAST __int64
#else
#define MYCAST int
#endif

extern int unicodemode;

uint compressionlevel = 6;

uint intstatus = 0;

int erroglobal = 0;

int isgzip2 = 0;

extern int zlibpercent;

__int64 lffilesize (const char *szFileName);

uint __stdcall rspcompress (char *inputfile, char *outfile);
int zcompress_sha512_k (char *input, char *output, int levelin);
uint __stdcall rspuncompress (uchar * outfile, uchar * outfile2);

int    zuncompress (char *input, char *output);
int    zcompress (char *input, char *output, int level);

int utf8towide (const char *pUTF8, WCHAR * pUSC2, int nUSC2);

WCHAR* utf8towide_v2 (const char *pUTF8)
{
/* nUSC2 is the number of characters, not chars */
	static WCHAR pUSC2[300];
	MultiByteToWideChar (CP_UTF8, 0, (LPCSTR) pUTF8, -1, pUSC2, 300);
	return pUSC2;
}

static float inittimer (uint comando)
{

	static uint clock1;
	static uint clock2;

	if (comando == 0)
	{
		clock1 = clock ();
		return 0;

	}
	else
	{

		clock2 = clock ();

		return ((float) clock2 - (float) clock1) / 1000;

	}
	/*
	   inittimer(0);
	   Sleep(1234);
	   Sleep(25);

	   ;//dprintf("Clock %f \n ", inittimer(1));
	 */

};

typedef void *myfile;

// basta passar o endereco
int    gzclose (myfile file);

myfile gzopen (char *path_now_as_utf8, char *mode);

int    gzread (myfile file, char *buf, uint len);

char  *gzerror (myfile file, int *errnum);

int    gzwrite (myfile file, const char *buf, uint len);

float  inittimer (uint comando);

void   dprintf (char *format, ...);

uint __stdcall rspvalidatefile (uchar * outfile2);

int __stdcall startapi (int parameter);


uchar intoutfile[255];
uchar intinputfile[255];
uint comando;


// variaveis globais do programa


uint pauseflag;
uint cancelflag;
uint filesize;

uint fileread;
uint intret;
uint finished;

uint getval (int max, uint por)
{

// a formula aqui é
// max / 100 * por

	uint ret;
	double maxa;
	double porr;

	maxa = (double) max;
	porr = (double) por;

	maxa = (maxa / 100) * porr;

	return (uint) maxa;

}

/*

   a formula aqui é (100/max * fatia)
   aqui é para saber a porcentagem referente ao valor passado em relacao ao maximo

   max = 10000
   fatia = 5000
   result = 50
 */
static uint getpor (int max, uint fatia)
{

	uint ret;
	double maxa;
	double fatiaa;

	maxa = (double) max;
	fatiaa = (double) fatia;

	if (max == 0)
	{
		return 0;
	}

	maxa = ((double) 100 / maxa * fatiaa);




	return (uint) maxa;

}

/*
   a formula aqui é (fatia/porcentagem) * 100
   o resultado é sempre uma porcentagem

   por = 70
   fatia = 10000
   result = 142

   basicamente é para saber o maximo a partir da fatria e da porcentagem
   sera pouco utilizada esta funcao
 */
uint                            // pegar o maximo a partir da porcentagem
getmax (int por, uint fatia)
{

	uint ret;
	float a;
	float b;

	a = (float) por;
	b = (float) fatia;

	if (por == 0)
	{
		return 0;
	}

	a = (b / a) * (float) 100;



	return (uint) a;

}









// definicao do ;//dprintf
//#define RSPDEBUG



//
//uint
//getfilesize (char *infile)
//{
//
//  uint ret;
//
//  FILE *myfile;
//
//  if ((myfile = fopen (infile, "rb")) == NULL)
//    {
//      ;//dprintf ("The file 'data' was not opened\n");
//      return 0;
//    }
//  else
//    {
//      ;//dprintf ("The file 'data' was opened\n");
//    }
//
//  ret = fseek (myfile, 0, SEEK_END);
//
//  ret = ftell (myfile);
//
//  ;//dprintf ("tamanho do arquivo %d\n ", ret);
//
//  fclose (myfile);
//
//  printf ("Tamanho do arquivo %s  %d \n", infile, ret);
//
//  return ret;
//
//
//}

//definicao de DLLMain

BOOL WINAPI DllMain (HINSTANCE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		OutputDebugString ("Gzip DLL DLL_PROCESS_ATTACH (" __TIME__ " " __DATE__ ") \n");


#ifdef NPRINTF
//Beep (2000, 50);
		MessageBox (0, "Bhond debugging code", "BW", MB_OK | MB_TOPMOST);
#endif
		break;
	case DLL_THREAD_ATTACH:
		//OutputDebugString ("arab DLL_THREAD_ATTACH \n");
		break;
	case DLL_THREAD_DETACH:
		//OutputDebugString ("arab DLL_THREAD_DETACH \n");
		break;
	case DLL_PROCESS_DETACH:
		//OutputDebugString ("arab DLL_PROCESS_DETACH \n");
		break;
	}
	return TRUE;
}



/*OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
   OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
   OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
   OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO*/



uint __stdcall rspcompress (char *inputfile, char *outfile)
{
//unicodemode = 1;

	int returnvalue = 0;

	int ret;
	int ret2;

	int ret3 = 0;
	char  *string;

	uchar buf[4097];

	FILE  *input;
	myfile output;
	;                       //dprintf ("Estamos ai \n ");


	// inittimer (0);

	pauseflag = 0;
	cancelflag = 0;


	filesize = lffilesize (inputfile);

//lffilesize (input);

	;                       //dprintf ("inputfile %s  outputfile %s  \n", inputfile, outfile);
//return 0;
#ifdef NPRINTF
	dprintf("certeira \n");
	dprintf("Compression level %d\n",compressionlevel);
#endif

	switch (compressionlevel)
	{

	case 0:
		output = gzopen (outfile, "wb0h");
		break;

	case 1:
		output = gzopen (outfile, "wb1h");
		break;
	case 2:
		output = gzopen (outfile, "wb2h");
		break;
	case 3:
		output = gzopen (outfile, "wb3h");
		break;
	case 4:
		output = gzopen (outfile, "wb4h");
		break;
	case 5:
		output = gzopen (outfile, "wb5h");
		break;
	case 6:
		output = gzopen (outfile, "wb6f");
		break;
	case 7:
		output = gzopen (outfile, "wb7f");
		break;
	case 8:
		output = gzopen (outfile, "wb8f");
		break;
	case 9:
#ifdef NPRINTF
		dprintf("Usou modo 9 \n");
#endif
		output = gzopen (outfile, "wb9f");
		break;
	default:
		output = gzopen (outfile, "wb6f");
		break;


	}




	if (output == NULL)
	{

		finished = 1;

		;               //dprintf ("Error openning gzip file for write \n ");
		return 8;       //Error opening input file

	}
	else
	{
		;               //dprintf ("OK openning gzip file for write \n ");
	}
	if(unicodemode)
	{
		WCHAR wpmode[300] ={0,};
		utf8towide (inputfile, wpmode, 300);
		input = _wfopen (wpmode, L"rb");
	}
	else
		input = fopen (inputfile, "rb");

	if (input == NULL)
	{
		finished = 1;
		;               //dprintf ("Error openning input file for write \n ");


		/*falta fechar arquivo */
		gzclose (output);
		return 7;       //Error openning output file
	}
	else
	{
		;               //dprintf ("OK openning input file for read \n ");
	}


	fileread = 0;


#ifdef NPRINTF
	dprintf ("verificando \n");
#endif

	while (1)
	{

		while (pauseflag)
		{


			Sleep (50);

			if (cancelflag)
			{
				returnvalue = 19;
				goto saida;
			}


		}

		if (cancelflag)
		{
			returnvalue = 19;
			goto saida;
		}

		ret = fread (buf, 1, 4096, input);


//const char*  gzerror (myfile file, int *errnum);


		if (ret <= 0)
		{
			break;
		}

		fileread = fileread + ret;

// int __stdcall gzwrite (myfile  file , const char *buf , uint len ) ;
		ret2 = gzwrite (output, buf, ret);






		string = gzerror (output, &ret3);

		//dprintf ("%d .%s. \n", ret3, string);
		if (ret3)
		{
			returnvalue = 14;

		}





	}

saida:

	fclose (input);

	gzclose (output);
	// ;//dprintf ("rspcompress tempo %f \n ", inittimer (1));
	finished = 1;


	return returnvalue;

}

//def.def


/*HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
   HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
   HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
   HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
   HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
   HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
   HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
   HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH*/




uint __stdcall rspuncompress (uchar * outfile, uchar * outfile2)
{
	//unicodemode = 1;
	int ret;
	int ret2;
	int returnvalue = 0;
	int ret3 = 0;
	char  *string;
//char inputfile[255] = "c:\\docs\\momento.txt" ;
//char outfile[255] = "c:\\docs\\momento.gz" ;

	uchar buf[4097];

	FILE  *input;
	myfile output;
	;                       //dprintf ("Estamos ai \n ");

	// inittimer (0);


	pauseflag = 0;
	cancelflag = 0;


	filesize = lffilesize (outfile);
//Beep(2000,2000);
/*
   if (rspvalidatefile (outfile))
     {
        finished = 1;
        return 9;		//invalid gzip file


     }
 */

	output = gzopen (outfile, "rb");


	if (output == NULL)
	{
		finished = 1;
		;               //dprintf ("Error opening gzip file for write \n ");
		return 10;

	}
	else
	{
		;               //dprintf ("OK openning gzip file for write \n ");
	}

	if(unicodemode)
	{
		WCHAR wpmode[300] ={0,};
		utf8towide (outfile2, wpmode, 300);
		input = _wfopen (wpmode, L"wb");
	}
	else
		input = fopen (outfile2, "wb");

	if (input == NULL)
	{
		finished = 1;
		;               //dprintf ("Error openning input file for write \n ");

		/*ta,bem falta fechar arquivo */
		gzclose (output);
		return 11;
	}
	else
	{
		;               //dprintf ("OK openning input file for read \n ");
	}

	fileread = 0;

	while (1)
	{



		while (pauseflag)
		{


			Sleep (50);

			if (cancelflag)
			{
				returnvalue = 19;
				goto saida;
			}


		}

		if (cancelflag)
		{
			returnvalue = 19;
			goto saida;
		}



		//int __stdcall gzread ( myfile file , char  *buf , uint len) ;
		ret = gzread (output, buf, 4096);

		string = gzerror (output, &ret3);

#ifdef NPRINTF
		dprintf ("%d .%s. \n", ret3, string);
#endif

		if ((ret3 != 0) && (ret3 != 1))
		{

			returnvalue = 15;
		}



		if (ret <= 0)
		{
			break;
		}

		fileread = fileread + ret;

// int __stdcall gzwrite (myfile  file , const char *buf , uint len ) ;

		ret2 = fwrite (buf, 1, ret, input);

	}


saida:

	fclose (input);

	gzclose (output);

	//;//dprintf ("rspuncompress tempo  %f \n ", inittimer (1));
	finished = 1;
	return returnvalue;



}

/*OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
   OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
   OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
   OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO*/

/*
   uint __stdcall rspvalidatefile (uchar * outfile2)
   {
   unicodemode = 1;
        uchar buf[4097];
        int ret;

        FILE  *input;
        myfile output;
        ;                       //dprintf ("Estamos ai \n ");

        input = fopen (outfile2, "rb");

        if (input == NULL)
        {
                ;               //dprintf ("Error openning input file for write \n ");
                return 3;
        }
        else
        {
                ;               //dprintf ("OK openning input file for read \n ");
        }



        ret = fread (buf, 1, 4096, input);



        fclose (input);


        if (ret < 20)
        {
                return 1;       // file too small
        }

        if (buf[0] == 0x1f)
        {
                if (buf[1] == 0x8b)
                {
                        if (buf[2] == 0x08)
                        {
                                return 0;
                        }
                        else
                        {
                                return 2;
                        }
                }
                else
                {
                        return 2;
                }
        }
        else
        {
                return 2;
        }

   }
 */
/*OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
   OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
   OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
   OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO*/



uint __stdcall getporcentagem ()
{

	uint ret;


	if (isgzip2)
	{
		ret = zlibpercent;
	}
	else
	{
		if (filesize == 0)
		{

			return 0;

		}

		ret = getpor (filesize, fileread);
	}
	// para evitar problemas maiores
	// agora deve gerar para criar thread e aguardar a finalizacao
	if (ret > 100)
	{
		ret = 100;
	}

	if (ret < 0)
	{
		ret = 0;
	}

	return ret;



}


/*HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
   HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
   HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
   HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH*/

/*HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
   HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
   HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
   HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH*/




uint __stdcall tcompress (char *inputfile, char *outfile)
{

// aqui tem que criar thread verifique

//uchar intoutfile[255] ;
//uchar intinputfile[255];
	HANDLE myhandle;
	MYCAST ThreadId;
	MYCAST parameter = 1;

	comando = 0;
	intret = 0;
	strcpy (intoutfile, outfile);

	strcpy (intinputfile, inputfile);

	myhandle = CreateThread ((LPSECURITY_ATTRIBUTES) 0, (SIZE_T)0, (LPTHREAD_START_ROUTINE) startapi, (LPVOID) parameter, (DWORD) 0, (LPDWORD) &ThreadId);

	CloseHandle (myhandle);
/*
   HANDLE CreateThread(
   LPSECURITY_ATTRIBUTES lpThreadAttributes,  // pointer to security attributes
   DWORD dwStackSize,                         // initial thread stack size
   LPTHREAD_START_ROUTINE lpStartAddress,     // pointer to thread function
   LPVOID lpParameter,                        // argument for new thread
   DWORD dwCreationFlags,                     // creation flags
   LPDWORD lpThreadId                         // pointer to receive thread ID
   );


 */
	return 0;

}

/*OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
   OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
   OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
   OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO*/


uint __stdcall tuncompress (uchar * outfile, uchar * outfile2)
{

	HANDLE myhandle;
	MYCAST ThreadId;
	MYCAST parameter = 1;
	comando = 1;

	//uchar intoutfile[255] ;
//uchar intinputfile[255];

	intret = 0;

	strcpy (intoutfile, outfile2);

	strcpy (intinputfile, outfile);
// intinputfile[255];

	myhandle = CreateThread ((LPSECURITY_ATTRIBUTES) 0, 0, (LPTHREAD_START_ROUTINE) startapi, (LPVOID) parameter, (DWORD) 0, (LPDWORD) &ThreadId);

/*HANDLE CreateThread(
   LPSECURITY_ATTRIBUTES lpThreadAttributes,  // pointer to security attributes
   DWORD dwStackSize,                         // initial thread stack size
   LPTHREAD_START_ROUTINE lpStartAddress,     // pointer to thread function
   LPVOID lpParameter,                        // argument for new thread
   DWORD dwCreationFlags,                     // creation flags
   LPDWORD lpThreadId   */

	CloseHandle (myhandle);

	return 0;

}

/*OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
   OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
   OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
   OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO*/


uint __stdcall tcompressgzip2 (char *inputfile, char *outfile)
{
	HANDLE myhandle;
	MYCAST ThreadId;
	MYCAST parameter = 1;
	comando = 2;
	intret = 0;
	strcpy (intoutfile, outfile);
	strcpy (intinputfile, inputfile);
	myhandle = CreateThread ((LPSECURITY_ATTRIBUTES) 0, 0, (LPTHREAD_START_ROUTINE) startapi, (LPVOID) parameter, (DWORD) 0, (LPDWORD) &ThreadId);
	CloseHandle (myhandle);
	return 0;
}


uint __stdcall tcompressgzip2_sha512_k (char *inputfile, char *outfile)
{
	HANDLE myhandle;
	MYCAST ThreadId;
	MYCAST parameter = 1;
	comando = 10002;
	intret = 0;
	strcpy (intoutfile, outfile);
	strcpy (intinputfile, inputfile);
	myhandle = CreateThread ((LPSECURITY_ATTRIBUTES) 0, 0, (LPTHREAD_START_ROUTINE) startapi, (LPVOID) parameter, (DWORD) 0, (LPDWORD) &ThreadId);
	CloseHandle (myhandle);
	return 0;
}


uint __stdcall tuncompressgzip2 (uchar * outfile, uchar * outfile2)
{

	HANDLE myhandle;
	MYCAST ThreadId;
	MYCAST parameter = 1;
	comando = 3;
	intret = 0;
	strcpy (intoutfile, outfile2);
	strcpy (intinputfile, outfile);
	myhandle = CreateThread ((LPSECURITY_ATTRIBUTES) 0, 0, (LPTHREAD_START_ROUTINE) startapi, (LPVOID) parameter, (DWORD) 0, (LPDWORD) &ThreadId);
	CloseHandle (myhandle);
	return 0;
}



uint __stdcall tcompressgzip2_utf8_k (char *inputfile, char *outfile)
{
	HANDLE myhandle;
	MYCAST ThreadId;
	MYCAST parameter = 1;
	comando = 10000;
	intret = 0;
	strcpy (intoutfile, outfile);
	strcpy (intinputfile, inputfile);
	myhandle = CreateThread ((LPSECURITY_ATTRIBUTES) 0, 0, (LPTHREAD_START_ROUTINE) startapi, (LPVOID) parameter, (DWORD) 0, (LPDWORD) &ThreadId);
	CloseHandle (myhandle);
	return 0;
}

uint __stdcall tuncompressgzip2_utf8_k (uchar * outfile, uchar * outfile2)
{

	HANDLE myhandle;
	MYCAST ThreadId;
	MYCAST parameter = 1;
	comando = 10001;
	intret = 0;
	strcpy (intoutfile, outfile2);
	strcpy (intinputfile, outfile);
	myhandle = CreateThread ((LPSECURITY_ATTRIBUTES) 0, 0, (LPTHREAD_START_ROUTINE) startapi, (LPVOID) parameter, (DWORD) 0, (LPDWORD) &ThreadId);
	CloseHandle (myhandle);
	return 0;
}

int __stdcall startapi (int parameter)
{
	// tem que receber as variaveis globais e mandar brasa
	;                       //dprintf ("parametro passado %d\n ", parameter);

	if (0 == comando)
	{
		unicodemode = 0;
		intret = rspcompress (intinputfile, intoutfile);

	}

	if (1 == comando)
	{
		unicodemode = 0;
		intret = rspuncompress (intinputfile, intoutfile);
	}

	if (2 == comando)
	{

		intret = zcompress (intinputfile, intoutfile, compressionlevel);

	}

	if (3 == comando)
	{

		intret = zuncompress (intinputfile, intoutfile);

	}


	if (10000 == comando)
	{
		unicodemode = 1;
		intret = rspcompress (intinputfile, intoutfile);

	}

	if (10001 == comando)
	{
		unicodemode = 1;
		intret = rspuncompress (intinputfile, intoutfile);
	}

if (10002 == comando)
	{
		unicodemode = 1;
		intret = zcompress_sha512_k (intinputfile, intoutfile, compressionlevel);
	}

	intstatus = 0;
	return intret;

}

/*OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
   OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
   OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
   OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO*/



int __stdcall getintret ()
{

	return intret;

}

int __stdcall getfinished ()
{

	return finished;

}

//funcao de timer para debug




int __stdcall setfinished (uint newvalue)
{

	uint ret;
	;                       //dprintf ("Setando setfinished %d \n", newvalue);
	finished = newvalue;



	return 0;

}




#ifdef WIN64
int __stdcall interface1 (__int64 argumento1, __int64 argumento2, __int64 argumento3, __int64 argumento4)
{
#else
int __stdcall interface1 (int argumento1, int argumento2, int argumento3, int argumento4)
{
#endif
	int ret;
	static uchar inputfile[255*6]; //for Unicode sake, (utf-8)
	static uchar inputfile2[255*6];
	static uchar outputfile[255*6];
	static uchar key[255*6];
	static uchar key2[255*6];
	uint intsize;
	static uint devnum;

	uint intargci;










	if (!strcmp ((char *) argumento1, "compress"))
	{
		memset (inputfile, 0, 255);
		memset (outputfile, 0, 255);
		memset (key, 0, 256);
		// memset (key2, 0, 256);

		isgzip2 = 0;
		intstatus = 1;

		;               //dprintf ("compress\n");

		strcpy (inputfile, (char *) argumento2);

		strcpy (inputfile2, (char *) argumento3);

		// strcpy (outputfile, (char *) argumento3);

		//strcpy (key, (char *) argumento4);

		;               //dprintf ("arquivo1 *%s* \n ", inputfile);
		;               //dprintf ("arquivo2 *%s* \n ", inputfile2);

//;//dprintf ("argumento 2 %s \n ", key);


//uint __stdcall
		return tcompress (inputfile, inputfile2);


	}


	if (!strcmp ((char *) argumento1, "compressgzip2"))
	{
		memset (inputfile, 0, 255);
		memset (outputfile, 0, 255);
		memset (key, 0, 256);
		// memset (key2, 0, 256);

		isgzip2 = 1;
		intstatus = 1;

		;               //dprintf ("compress\n");

		strcpy (inputfile, (char *) argumento2);

		strcpy (inputfile2, (char *) argumento3);

		// strcpy (outputfile, (char *) argumento3);

		//strcpy (key, (char *) argumento4);

		;               //dprintf ("arquivo1 *%s* \n ", inputfile);
		;               //dprintf ("arquivo2 *%s* \n ", inputfile2);

//;//dprintf ("argumento 2 %s \n ", key);


//uint __stdcall
		return tcompressgzip2 (inputfile, inputfile2);


	}
	
	
	if (!strcmp ((char *) argumento1, "compressgzip2_sha512_k"))
	{
		memset (inputfile, 0, 255);
		memset (outputfile, 0, 255);
		memset (key, 0, 256);
		// memset (key2, 0, 256);

		isgzip2 = 1;
		intstatus = 1;

		;               //dprintf ("compress\n");

		strcpy (inputfile, (char *) argumento2);

		strcpy (inputfile2, (char *) argumento3);

		// strcpy (outputfile, (char *) argumento3);

		//strcpy (key, (char *) argumento4);

		;               //dprintf ("arquivo1 *%s* \n ", inputfile);
		;               //dprintf ("arquivo2 *%s* \n ", inputfile2);

//;//dprintf ("argumento 2 %s \n ", key);


//uint __stdcall
		return tcompressgzip2_sha512_k(inputfile, inputfile2);


	}
	


	if (!strcmp ((char *) argumento1, "compressgzip2_utf8_k"))
	{
		memset (inputfile, 0, 255);
		memset (outputfile, 0, 255);
		memset (key, 0, 256);
		// memset (key2, 0, 256);

		isgzip2 = 0;
		intstatus = 1;

		;               //dprintf ("compress\n");

		strcpy (inputfile, (char *) argumento2);

		strcpy (inputfile2, (char *) argumento3);

		// strcpy (outputfile, (char *) argumento3);

		//strcpy (key, (char *) argumento4);

		;               //dprintf ("arquivo1 *%s* \n ", inputfile);
		;               //dprintf ("arquivo2 *%s* \n ", inputfile2);

//;//dprintf ("argumento 2 %s \n ", key);


//uint __stdcall
		return tcompressgzip2_utf8_k (inputfile, inputfile2);


	}


	if (!strcmp ((char *) argumento1, "uncompress"))
	{
		memset (inputfile, 0, 255);
		memset (outputfile, 0, 255);

		;               //dprintf ("uncompress\n");

		strcpy (inputfile, (char *) argumento2);

		strcpy (inputfile2, (char *) argumento3);
		intstatus = 1;
		isgzip2 = 0;
		;               //dprintf ("arquivo1 *%s* \n ", inputfile);
		;               //dprintf ("arquivo2 *%s* \n ", inputfile2);


		return tuncompress (inputfile, inputfile2);


	}

	if (!strcmp ((char *) argumento1, "uncompressgzip2"))
	{
		memset (inputfile, 0, 255);
		memset (outputfile, 0, 255);

		;               //dprintf ("uncompress\n");

		strcpy (inputfile, (char *) argumento2);

		strcpy (inputfile2, (char *) argumento3);
		intstatus = 1;
		isgzip2 = 1;
		;               //dprintf ("arquivo1 *%s* \n ", inputfile);
		;               //dprintf ("arquivo2 *%s* \n ", inputfile2);


		return tuncompressgzip2 (inputfile, inputfile2);


	}


	if (!strcmp ((char *) argumento1, "uncompressgzip2_utf8_k"))
	{
		memset (inputfile, 0, 255);
		memset (outputfile, 0, 255);

		;               //dprintf ("uncompress\n");

		strcpy (inputfile, (char *) argumento2);

		strcpy (inputfile2, (char *) argumento3);
		intstatus = 1;
		isgzip2 = 0;
		;               //dprintf ("arquivo1 *%s* \n ", inputfile);
		;               //dprintf ("arquivo2 *%s* \n ", inputfile2);


		return tuncompressgzip2_utf8_k (inputfile, inputfile2);


	}

	if (!strcmp ((char *) argumento1, "setfinished"))
	{
//memset (inputfile, 0, 255);
		//   memset (outputfile, 0, 255);

		;               //dprintf ("setfinished\n");

		// strcpy (inputfile, (char *) argumento2);

		//  strcpy (inputfile2, (char *) argumento3);


//;//dprintf ("arquivo1 *%s* \n ", inputfile);
//;//dprintf ("arquivo2 *%s* \n ", inputfile2);

		setfinished (argumento2);


		return 0;


	}



	if (!strcmp ((char *) argumento1, "getfinished"))
	{
//memset (inputfile, 0, 255);
		//   memset (outputfile, 0, 255);

		;               //dprintf ("getfinished\n");

		// strcpy (inputfile, (char *) argumento2);

		//  strcpy (inputfile2, (char *) argumento3);


//;//dprintf ("arquivo1 *%s* \n ", inputfile);
//;//dprintf ("arquivo2 *%s* \n ", inputfile2);

		return getfinished ();





	}


	if (!strcmp ((char *) argumento1, "getporcentagem"))
	{
//memset (inputfile, 0, 255);
		//   memset (outputfile, 0, 255);

		;               //dprintf ("getporcentagem\n");

		// strcpy (inputfile, (char *) argumento2);

		//  strcpy (inputfile2, (char *) argumento3);


//;//dprintf ("arquivo1 *%s* \n ", inputfile);
//;//dprintf ("arquivo2 *%s* \n ", inputfile2);

		return getporcentagem ();





	}


	if (!strcmp ((char *) argumento1, "pause"))
	{
//memset (inputfile, 0, 255);
		//   memset (outputfile, 0, 255);

		;               //dprintf ("pause\n");

		pauseflag = 1;




		return 0;





	}

	if (!strcmp ((char *) argumento1, "resume"))
	{
//memset (inputfile, 0, 255);
		//   memset (outputfile, 0, 255);

		;               //dprintf ("pause\n");

		pauseflag = 0;




		return 0;





	}


	if (!strcmp ((char *) argumento1, "cancel"))
	{
//memset (inputfile, 0, 255);
		//   memset (outputfile, 0, 255);

		;               //dprintf ("pause\n");

		pauseflag = 1;
		cancelflag = 1;

		while (intstatus)
		{
#ifdef NPRINTF
			dprintf ("Loopeando no cancel \n");
#endif
			Sleep (50);

		}


		return 0;





	}


	if (!strcmp ((char *) argumento1, "getintret"))
	{
//memset (inputfile, 0, 255);
		//   memset (outputfile, 0, 255);

		;               //dprintf ("pause\n");

		return getintret ();


	}



	if (!strcmp ((char *) argumento1, "compressionlevel"))
	{
//memset (inputfile, 0, 255);
		//   memset (outputfile, 0, 255);

		;               //dprintf ("compressionlevel\n");


		switch (argumento2)
		{

		case 0:
			break;

		case 1:
			break;
		case 2:
			break;
		case 3:
			break;
		case 4:
			break;
		case 5:
			break;
		case 6:
			break;
		case 7:
			break;
		case 8:
			break;
		case 9:
			break;

		default:

			return 1;


		}

		compressionlevel = argumento2;

		return 0;





	}



	if (!strcmp ((char *) argumento1, "status"))
	{


		return intstatus;




	}


	assert(0);


	return 0;

}

int unicodemode=0;

void mprintf2 (char *format, ...)
{
// para imprimir messagebox quando necessario
//#pragma comment (lib,"user32.lib")

	{
		int val;

		va_list args;
		static char buffer[500000];
		int ret;
		va_start (args, format);
		ret = vsprintf (buffer, format, args);
		val = MessageBox (0, buffer, "BW", MB_OK | MB_TOPMOST);

		if (val != IDOK)
		{
			// exit (1);

		}
	}
}

int __stdcall ControlName (char *data)
{
	strcpy (data, "BW Gzip DLL " AMARIC__VERSION
	 #ifdef WIN64
	        " 64 bits"
	 #else
	        " 32 bits"
	 #endif
	        );
	return 0;
}

int __stdcall About ()
{
	mprintf2 ("Win32 and Win64 DLL to compress or uncompress gzip and gzip2 files");
	return 0;
}


int wait = 0;

int __stdcall WaitExecution (int val)
{
	wait = val;
	return 0;
}

void __stdcall PauseExecution()
{
	pauseflag = 1;
}
void __stdcall ResumeExecution()
{
	pauseflag = 0;
}
void __stdcall CancelExecution()
{
	pauseflag = 1;
	cancelflag = 1;

	while (intstatus)
	{
#ifdef NPRINTF
		dprintf ("Loopeando no cancel \n");
#endif
		Sleep (50);

	}
}

int __stdcall Compress (char *Inputfile, char *OutPutFile, int CompressionLevel)
{

	if (0 != interface1 ((MYCAST) "status", 0, 0, 0))
	{
		return 13;
	}


	if (0 != interface1 ((MYCAST) "compressionlevel", (MYCAST) CompressionLevel, 0, 0))
	{

		return 12;
	}

	interface1 ((MYCAST) "setfinished", 0, 0, 0);

	interface1 ((MYCAST) "compress", (MYCAST) Inputfile, (MYCAST) OutPutFile, (MYCAST) "file3");

volta:

	if (wait)
	{
		Sleep (50);
		if (0 == interface1 ((MYCAST) "getfinished", (MYCAST) " ", (MYCAST) " ", (MYCAST) " "))
		{

			goto volta;
		}

	}
	return 0;
}

int __stdcall CompressGzip2(char* Inputfile, char* OutPutFile, int CompressionLevel )
{
	unicodemode=1;
	if(0!=((MYCAST)"status", 0, 0, 0))
	{
		return 13;
	}

	if(0!=interface1((MYCAST)"compressionlevel", (MYCAST)CompressionLevel, 0, 0))
	{

		return 12;
	}


	interface1((MYCAST) "setfinished", 0, 0, 0);

	interface1((MYCAST) "compressgzip2", (MYCAST)Inputfile, (MYCAST)OutPutFile, (MYCAST)"file3");

volta:

	if (wait)
	{
		Sleep (50);
		if (0 == interface1 ((MYCAST) "getfinished", (MYCAST) " ", (MYCAST) " ", (MYCAST) " "))
		{

			goto volta;
		}

	}

	return 0;
}

int __stdcall CompressGzip2_SHA512_k(char* Inputfile, char* OutPutFile, int CompressionLevel )
{
	unicodemode=1;
	if(0!=((MYCAST)"status", 0, 0, 0))
	{
		return 13;
	}

	if(0!=interface1((MYCAST)"compressionlevel", (MYCAST)CompressionLevel, 0, 0))
	{

		return 12;
	}

	interface1((MYCAST) "setfinished", 0, 0, 0);

	interface1((MYCAST) "compressgzip2_sha512_k", (MYCAST)Inputfile, (MYCAST)OutPutFile, (MYCAST)"file3");

volta:

	if (wait)
	{
		Sleep (50);
		if (0 == interface1 ((MYCAST) "getfinished", (MYCAST) " ", (MYCAST) " ", (MYCAST) " "))
		{

			goto volta;
		}

	}

	return 0;
}
int __stdcall CompressGzip_utf8_k(char* Inputfile, char* OutPutFile, int CompressionLevel )
{

	if(0!=((MYCAST)"status", 0, 0, 0))
	{
		return 13;
	}

	if(0!=interface1((MYCAST)"compressionlevel", (MYCAST)CompressionLevel, 0, 0))
	{

		return 12;
	}

	compressionlevel = CompressionLevel;

	interface1((MYCAST) "setfinished", 0, 0, 0);

	interface1((MYCAST) "compressgzip2_utf8_k", (MYCAST)Inputfile, (MYCAST)OutPutFile, (MYCAST)"file3");

volta:

	if (wait)
	{
		Sleep (50);
		if (0 == interface1 ((MYCAST) "getfinished", (MYCAST) " ", (MYCAST) " ", (MYCAST) " "))
		{

			goto volta;
		}

	}

	return 0;
}
int __stdcall GetFinished()
{
//ret = GZip.CallWindow("getfinished", " ", " ", " ")
	return interface1((MYCAST)"getfinished",(MYCAST) " ", (MYCAST)" ", (MYCAST)" ");
}


//ret = GZip.CallWindow("getintret", " ", " ", " ")

int __stdcall GetReturnValue()
{
	return interface1((MYCAST)"getintret", (MYCAST)" ", (MYCAST)" ", (MYCAST)" ");
}


//ret = GZip.CallWindow("getporcentagem", " ", " ", " ")

int __stdcall GetProgress()
{

	return interface1((MYCAST)"getporcentagem", (MYCAST)" ", (MYCAST)" ", (MYCAST)" ");
	return 0;
}


int __stdcall Uncompress(char* Inputfile, char* OutPutFile)
{
	int ret;

	if(0!=interface1((MYCAST)"status", 0, 0, 0) )
	{
		return 13;
	}

	interface1((MYCAST) "setfinished", 0, 0, 0);

	interface1((MYCAST) "uncompress", (MYCAST)Inputfile, (MYCAST)OutPutFile, (MYCAST)"file3");

volta:

	if (wait)
	{
		Sleep (50);
		if (0 == interface1 ((MYCAST) "getfinished", (MYCAST) " ", (MYCAST) " ", (MYCAST) " "))
		{

			goto volta;
		}

	}



	return 0;


}

int __stdcall UncompressGzip2(char* Inputfile, char* OutPutFile )
{
	int ret;

	unicodemode=1;
	if(interface1((MYCAST)"status", 0, 0, 0) )
	{

		return 13;

	}

	interface1((MYCAST) "setfinished", 0, 0, 0);


	interface1((MYCAST) "uncompressgzip2", (MYCAST)Inputfile, (MYCAST)OutPutFile, (MYCAST)"file3");

volta:

	if (wait)
	{
		Sleep (50);
		if (0 == interface1 ((MYCAST) "getfinished", (MYCAST) " ", (MYCAST) " ", (MYCAST) " "))
		{

			goto volta;
		}

	}

	return 0;
}

int __stdcall UncompressGzip_utf8_k(char* Inputfile, char* OutPutFile )
{
	int ret;

	unicodemode=1;
	if(interface1((MYCAST)"status", 0, 0, 0) )
	{

		return 13;

	}

	interface1((MYCAST) "setfinished", 0, 0, 0);


	interface1((MYCAST) "uncompressgzip2_utf8_k", (MYCAST)Inputfile, (MYCAST)OutPutFile, (MYCAST)"file3");

volta:

	if (wait)
	{
		Sleep (50);
		if (0 == interface1 ((MYCAST) "getfinished", (MYCAST) " ", (MYCAST) " ", (MYCAST) " "))
		{

			goto volta;
		}

	}

	return 0;
}

int __stdcall stringtobyte (unsigned char *dest, unsigned char *src, int len)
{
	int i;
	for (i = 0; i < len; i++)
	{
		//dprintf("item < %d  %d \n",src[i], i);
		dest[i] = src[i];
	}
	//dest[i]=0;
	return 0;
}
int __stdcall bytetostring (unsigned char *dest, unsigned char *src, int len)
{
	int i;
	for (i = 0; i < len; i++)
	{
		//dprintf("item < %d  %d \n",src[i], i);
		dest[i] = src[i];
	}
	dest[i] = 0;
	return 0;
}
